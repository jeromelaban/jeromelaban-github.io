---
layout: post
title: "Lambda Expression and ForEach loops"
date: 2008-11-18 20:58:00 -0500
comments: true
category: Archive
tags: [".NET"]
redirect_from: ["/post/2008/11/18/Lambda-Expression-and-ForEach-loops.aspx", "/post/2008/11/18/lambda-expression-and-foreach-loops.aspx"]
author: jay
---
<!-- more -->
<p>
<em>Cet article est <a href="http://blogs.codes-sources.com/jay/archive/2008/11/19/expressions-lambda-et-boucles-foreach.aspx" target="_blank" title="Expressions Lambda et boucles ForEach">disponible en fran&ccedil;ais</a>. </em>
</p>
<p>
To enhance the performances of a type serializer, and to use a small extension that I recently wrote for <a href="http://www.codeplex.com/umbrella" target="_blank" title="Umbrella - Codeplex">Umbrella</a> I stumbled upon an interesting small &quot;Side Effect&quot; seen when creating lambda expressions inside a foreach loop.
</p>
<p>
Let&#39;s take this simple piece of code : 
</p>
<p>
[code:c#]
<br />
&nbsp;&nbsp;&nbsp;    var actionList = new List&lt;Func&lt;int&gt;&gt;();<br />
<br />
&nbsp;&nbsp;&nbsp;    foreach (var value in Enumerable.Range(0, 10))<br />
&nbsp;&nbsp;&nbsp;    {<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;       actionList.Add(() =&gt; value);<br />
&nbsp;&nbsp;&nbsp;    }<br />
<br />
&nbsp;&nbsp;&nbsp;    actionList.ForEach(func =&gt; Console.Write(&quot;{0} &quot;, func()));
</p>
<p>
[/code]
</p>
<p>
Which outputs this : 
</p>
<p>
[code:c#]
<br />
&nbsp;&nbsp; 9 9 9 9 9 9 9 9 9 9
</p>
<p>
[/code]<br />
<br />
Which is, of course, what we could have expected.
</p>
<p>
Lambda expression have the ability to use variables that are in the scope when they are declared. This makes them very interesting, but to properly use them, it is best to understand how they are &quot;materialized&quot; by the compiler. 
</p>
<p>
Like a lot of features of C#, like the <a href="http://msdn.microsoft.com/en-us/library/aa664736.aspx" target="_blank" title="C# using">using</a>, foreach, <a href="http://msdn.microsoft.com/en-us/library/dscyy5s0.aspx" target="_blank" title="C# Iterators">iterators</a> or <a href="http://msdn.microsoft.com/en-us/library/c5kehkcz%28VS.80%29.aspx" target="_blank" title="C# lock">lock</a>, lambdas are syntactic sugar destined to simplify the writing of code that is most of the time pretty verbose. It is possible to write the expanded code for these keyswords in C#.<br />
<br />
Let&#39;s take this other piece of code :<br />
<br />
<span style="color: Black; background-color: transparent; font-family: Courier New; font-size: 11px; font-weight: normal"></span>[code:c#]
<br />
&nbsp; &nbsp;    int a = 0;<br />
&nbsp;&nbsp;&nbsp;    Action action = () =&gt; Console.WriteLine(a);<br />
&nbsp;&nbsp;&nbsp;    action();
</p>
<p>
[/code]
</p>
<p>
<br />
The lambda expression is &quot;materialized&quot; by the C# compiler under the form of a &quot;Display Class&quot;, that allows the storage of the local variable &quot;a&quot; :<br />
<br />
[code:c#]
<br />
<br />
&nbsp;&nbsp;&nbsp; [CompilerGenerated]<br />
&nbsp;&nbsp;&nbsp;   private sealed class &lt;&gt;c__DisplayClass1<br />
&nbsp;&nbsp;&nbsp;   {<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;       public int a;<br />
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;       public void &lt;Main&gt;b__0()<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;       {<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;          Console.WriteLine(this.a);<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;       }<br />
&nbsp;&nbsp;&nbsp;   }
<br />
[/code]
</p>
<p>
We can see that the indentifiers for the generated class are not valid in C#, but are valide from the CLR point of view. We can also see that the local variable used during the declaration is present as a member variable, in the class that contains the code of the lambda expression. The compiler will then write this to create an instance of the lambda expression :<br />
<br />
[code:c#]
<br />
&nbsp;&nbsp;&nbsp;            int a = 0;<br />
<br />
&nbsp;&nbsp;&nbsp;            var display = new &lt;&gt;c__DisplayClass1();<br />
&nbsp;&nbsp;&nbsp;            display.a = a;<br />
<br />
&nbsp;&nbsp;&nbsp;            Action action = new Action(display.&lt;Main&gt;b__0);<br />
<br />
&nbsp;&nbsp;&nbsp;            action();<br />
<br />
[/code]
</p>
<p>
<br />
There also, this is not valid C#.<br />
<br />
But then, what happens for the foreach case so that the content of the variable is repeated ?
</p>
<p>
If we analyze the first code sample generated by the compiler with <a href="http://www.red-gate.com/products/reflector/" target="_blank" title="Reflector">Reflector</a>, there is nothing much fancy to see with the C# visualizer :<br />
<br />
[code:c#]
<br />
&nbsp;&nbsp;&nbsp;    List&lt;Func&lt;int&gt;&gt; actionList = new List&lt;Func&lt;int&gt;&gt;();<br />
&nbsp;&nbsp;&nbsp;    using (IEnumerator&lt;int&gt; CS$5$0000 = Enumerable.Range(0, 10).GetEnumerator())<br />
&nbsp;&nbsp;&nbsp;    {<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        while (CS$5$0000.MoveNext())<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        {<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            int value = CS$5$0000.Current;<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            actionList.Add(delegate {<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                return value;<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            });<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        }<br />
&nbsp;&nbsp;&nbsp;    }<br />
<br />
[/code]
<br />
<br />
The lambda expression is represented as an anonymous method, which is a synonym of lambda, but that does not explain the behavior.
<br />
<br />
We must look at the generated IL to understand the behavior, and this is the correct C# code that is generated :<br />
<br />
[code:c#]
<br />
&nbsp;&nbsp;&nbsp;            List&lt;Func&lt;int&gt;&gt; actionList = new List&lt;Func&lt;int&gt;&gt;();<br />
&nbsp;&nbsp;&nbsp;            using (IEnumerator&lt;int&gt; CS$5$0000 = Enumerable.Range(0, 10).GetEnumerator())<br />
&nbsp;&nbsp;&nbsp;            {<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;               var myLambda = new &lt;&gt;c__DisplayClass4();<br />
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;               while (CS$5$0000.MoveNext())<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;               {<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                  int value = CS$5$0000.Current;<br />
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; myLambda.value = value;<br />
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                  actionList.Add(new Func&lt;int&gt;(myLambda.b_0));<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;               }<br />
&nbsp;&nbsp;&nbsp;            }<br />
<br />
[/code]<br />
<br />
We can easily see what the problem is : The instance of the class containing the lambda is created only once, and reused many times to assign a new value for each iteration. This explains why the execution of all the lambdas return the last enumerated value, because they all refer to the same instance of the &quot;DisplayClass&quot; type.
<br />
<br />
However, if we write the code this way :
</p>
<p>
<span style="color: Black; background-color: transparent; font-family: Courier New; font-size: 11px; font-weight: normal"></span>[code:c#]
<br />
&nbsp;&nbsp;&nbsp;            foreach (var value in Enumerable.Range(0, 10))<br />
&nbsp;&nbsp;&nbsp;            {<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                int myValue = value;<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                actionList.Add(() =&gt; myValue);<br />
&nbsp;&nbsp;&nbsp;            }<br />
<br />
[/code]
</p>
<p>
The behavior changes, and this time, each lambda has the correct value.
</p>
<p>
From the compiler point of view, the creation of a new instance for the container class must be the consequence of the creation of a new variable. For the case of a ForEach statement, this is not the case and the variable is treated as created only once, then reused..<br />
<br />
So, from the compiler point of view, a ForEach loop is expanded like this :
</p>
<p>
[code:c#]
<br />
&nbsp;&nbsp;&nbsp;            using (var it = Enumerable.Range(0, 10).GetEnumerator())<br />
&nbsp;&nbsp;&nbsp;            {<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                int value;<br />
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                while (it.MoveNext())<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                {<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                    value = it.Current;<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                    actionList2.Add(() =&gt; value);<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                }<br />
&nbsp;&nbsp;&nbsp;            }<br />
<br />
[/code]
<br />
<br />
This is probably a question of interpretation, but I wasn&#39;t exactly expecting this...
</p>
<p>
So, one must pay attention to the way local variables are used in lambda expressions, depending on their declaration location.
</p>
<p>
I&#39;ll explain in a later post why I did have to use lamda expressions in a ForEach loop.
</p>

{% include imported_disclaimer.html %}
