---
layout: post
title: "SyncProxy, an implicit synchronizer"
date: 2004-04-04 11:51:00 -0500
comments: true
category: Archive
tags: [".NET"]
redirect_from: ["/post/2004/04/04/SyncProxy2c-an-implicit-synchronizer.aspx", "/post/2004/04/04/syncproxy2c-an-implicit-synchronizer.aspx"]
author: jerome
---
<!-- more -->
<p>
<span style="font-size: 10pt; font-family: Tahoma">A few days ago, I ran into an <a href="http://msdn.microsoft.com/library/default.asp?url=/library/en-us/dnwinforms/html/SACP_WinForms.asp">MVP article on the MSDN</a> talking about synchronizing asynchronous calls to WebServices heading back to the GUI. Since asynchronous calls are processed in separate threads, it is not&nbsp;safe to call GUI methods directly from these. The article was describing how to create some sort of helper class (some call this an <em>Agent</em> or <em>Pattern</em>)&nbsp;that allows to hide the call to BeginInvoke, freeing the developper from creating many small methods that would only contain calls to BeginInvoke.</span>
</p>
<p>
<span style="font-size: 10pt; font-family: Tahoma">Back in dotnetSoul, I did not have to call WebServices - at least not in a repetitive way - but I had to synchronize calls from events generated by the netsoul core. These events are fired from asynchronous read operations on a network stream, which implies that consuming these from the GUI requires to synchronize the call to update some controls.</span>
</p>
<p>
<span style="font-size: 10pt; font-family: Tahoma">The old fashion way is to register a &quot;standard&quot; method which only calls the synchronous method via BeginInvoke with the same parameters :</span>
</p>
<p>
<span style="font-size: 10pt; font-family: 'Courier New'">&nbsp;&nbsp;&nbsp; _chatRoom.UserJoined&nbsp;+= <font color="#0000ff">new</font> EventHandler(OnChatRoomUserJoined);</span>
</p>
<p>
<span style="font-size: 10pt; font-family: 'Courier New'">...</span>
</p>
<p>
<span style="font-size: 10pt; font-family: 'Courier New'">&nbsp;&nbsp;&nbsp; <font color="#0000ff">private void</font> OnChatRoomUserJoined(<font color="#0000ff">object</font> sender, EventArgs args)<br />
&nbsp;&nbsp;&nbsp; {<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; BeginInvoke(<font color="#0000ff">new</font> SyncEventHandler(SyncChatRoomUserJoined), <font color="#0000ff">new object</font>[]{ sender, args });<br />
&nbsp;&nbsp;&nbsp; }<br />
<br />
&nbsp;&nbsp;&nbsp; <font color="#0000ff">private void</font> OnChatRoomUserJoined(<font color="#0000ff">object</font> sender, EventArgs args)<br />
&nbsp;&nbsp;&nbsp; {<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#006400">// call the UI from there...</font><br />
&nbsp;&nbsp;&nbsp; }</span>
</p>
<p>
<span style="font-size: 10pt; font-family: Tahoma">What a waste of time and error prone way of doing many GUI synchronous calls, since the netsoul core exposes about 20+ events to consumers. You might notice I&#39;m using a SyncEventHandler delegate. I&#39;m using this delegate to avoid the BeginMethod to change the parameters passed in.</span>
</p>
<p>
<span style="font-size: 10pt; font-family: Tahoma">So reminding the class used to synchronize the calls to the UI, I though I could create some sort of Proxy class that could be used to both register the event and create the instance of the proxy. I then came up with this :</span>
</p>
<p>
<span style="font-size: 10pt; font-family: 'Courier New'"><font color="#0000ff">using</font> System;<br />
<font color="#0000ff">using</font> System.Windows.Forms;</span>
</p>
<p>
<span style="font-size: 10pt; font-family: 'Courier New'"><font color="#0000ff">namespace</font> Epitech.NetSoul.UI<br />
{<br />
&nbsp;&nbsp;&nbsp; <font color="#0000ff">public delegate void</font> SyncEventHandler(<font color="#0000ff">object</font> sender, EventArgs args);</span>
</p>
<p>
<span style="font-size: 10pt; font-family: 'Courier New'">&nbsp;&nbsp;&nbsp; <font color="#0000ff">public class</font> SyncProxy<br />
&nbsp;&nbsp;&nbsp; {<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font color="#0000ff">private</font> Control&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_control;<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font color="#0000ff">private</font> SyncEventHandler&nbsp;&nbsp;&nbsp; _syncHandler;<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font color="#0000ff">private</font> EventHandler&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _asyncHandler;</span>
</p>
<p>
<span style="font-size: 10pt; font-family: 'Courier New'">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font color="#0000ff">public</font> SyncProxy(Control control, SyncEventHandler syncHandler)<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _control&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = control;<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _syncHandler&nbsp;&nbsp;&nbsp; = syncHandler;<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _asyncHandler&nbsp;&nbsp;&nbsp;= new EventHandler(AsyncHandler);<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br />
</span><span style="font-size: 10pt; font-family: 'Courier New'"><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font color="#006400">//&nbsp;Implicit operator to allow an easy registering&nbsp;on events</font><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font color="#0000ff">public static implicit operator</font> EventHandler(SyncProxy proxy)<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font color="#0000ff">return</font> proxy._asyncHandler;<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br />
<br />
<font color="#006400">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // The asynchronous delegate, which calls the synchronous delegate through<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //&nbsp;BeginInvoke, if required.</font><br />
</span><span style="font-size: 10pt; font-family: 'Courier New'">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font color="#0000ff">private void</font> AsyncHandler(<font color="#0000ff">object</font> sender, EventArgs args)<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font color="#0000ff">if</font>(_control.InvokeRequired)<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _control.BeginInvoke(_syncHandler, <font color="#0000ff">new object</font>[]{ sender, args });<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font color="#0000ff">else</font><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _syncHandler(sender, args);<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br />
&nbsp;&nbsp;&nbsp; }<br />
}</span>
</p>
<span style="font-size: 10pt; font-family: Tahoma">Which can be used like this :</span><span style="font-family: Tahoma"></span> 
<p>
<span style="font-size: 10pt; font-family: 'Courier New'">&nbsp;&nbsp;&nbsp;&nbsp;_chatRoom.UserJoined&nbsp;+= <font color="#0000ff">new</font> SyncProxy(<font color="#0000ff">this</font>, <font color="#0000ff">new</font> SyncEventHandler(OnChatRoomUserJoined));</span>
</p>
<p>
<span style="font-size: 10pt; font-family: Tahoma">This call creates the proxy then registers the asynchronous delegate from the proxy through an implicit cast to EventHandler. This way, there is only one event handler to create inside the destination form per event handled.</span>
</p>

{% include imported_disclaimer.html %}
