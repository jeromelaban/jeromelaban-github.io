---
layout: post
title: "Obscure abstraction stories"
date: 2004-04-14 11:55:41 -0500
comments: true
category: Archive
tags: ["Misc"]
redirect_from: ["/post/2004/04/14/Obscure-abstraction-stories.aspx", "/post/2004/04/14/obscure-abstraction-stories.aspx"]
author: jerome
---
<!-- more -->
<P style="TEXT-ALIGN: justify"><SPAN style="FONT-SIZE: 10pt; COLOR: black; FONT-FAMILY: Tahoma">Today, I was rating some students group for one of their project (called Zia, a Third Year project about creating an HTTP server) and they told me that they could not understand some very strange behavior of their software. To keep it short, they were having some really strange jumps from some functions to others, in some unrelated places. This is unusual, particularly when the function actually called is not the one that should be called in a virtual function context.</SPAN></P>
<P style="TEXT-ALIGN: justify"><SPAN style="FONT-SIZE: 10pt; FONT-FAMILY: Tahoma">The thing is, about this project, that it is required to have an extensible way of dealing with functionalities of an HTTP server in the form of Modules or Plug-ins. In an object oriented&nbsp;way of seeing things, two methods exist :</SPAN></P>
<UL type=disc>
<LI class=MsoNormal style="MARGIN: 0cm 0cm 0pt; TEXT-ALIGN: justify; mso-list: l2 level1 lfo1; tab-stops: list 36.0pt; mso-margin-top-alt: auto; mso-margin-bottom-alt: auto"><SPAN style="FONT-SIZE: 10pt; FONT-FAMILY: Tahoma">The first one is about using static referencing of types in a DLL, by means of directives like </SPAN><SPAN style="FONT-SIZE: 10pt; FONT-FAMILY: 'Courier New'">__dllimport</SPAN><SPAN style="FONT-SIZE: 10pt; FONT-FAMILY: Tahoma"> set on classes. This is an impracticable way for plug-in&nbsp;enumeration&nbsp;as this is "dynamic static" linking of functions, which is much like linking using a static library. An other problem with this kind of implementation is that it cannot be used to efficiently achieve abstraction using the C#-style (or java) interface because types are explicitly referenced from the dynamic library. Generally speaking, this is not a good choice (and this is also not portable).</SPAN> </LI>
<LI><SPAN style="FONT-SIZE: 10pt; FONT-FAMILY: Tahoma">An other one is about using a common interface <I style="mso-bidi-font-style: normal">(or fully abstract class, only pure virtual functions and no data members)</I> shared by both plug-ins and the host, and allowing <SPAN style="mso-spacerun: yes">&nbsp;</SPAN>plug-ins to create concrete instances of the common interface. This has multiple advantages :</SPAN> 
<UL type=circle>
<LI class=MsoNormal style="MARGIN: 0cm 0cm 0pt; TEXT-ALIGN: justify; mso-list: l2 level2 lfo1; tab-stops: list 72.0pt; mso-margin-top-alt: auto; mso-margin-bottom-alt: auto"><SPAN style="FONT-SIZE: 10pt; FONT-FAMILY: Tahoma">The host only imports a few "C-Style" functions (generally declared as </SPAN><SPAN style="FONT-SIZE: 10pt; FONT-FAMILY: 'Courier New'">extern "C"</SPAN><SPAN style="FONT-SIZE: 10pt; FONT-FAMILY: Tahoma">) used, for example,&nbsp;to create instances of concrete classes or to enumerate types that can be created by the module. This also removes the implications of the symbols decoration (or name mangling) generated by the C++ compiler, <I style="mso-bidi-font-style: normal">(By the way, the dependency walker is a great tool to see this)</I></SPAN> </LI>
<LI><SPAN style="FONT-SIZE: 10pt; FONT-FAMILY: Tahoma">Types Virtual Tables are automatically built using the DLL memory space, letting the C++ plumbing doing the job for the user,</SPAN> </LI>
<LI><SPAN style="FONT-SIZE: 10pt; FONT-FAMILY: Tahoma">It is also possible to enumerate, load or unload plug-ins on the fly,</SPAN> </LI>
<LI><SPAN style="FONT-SIZE: 10pt; FONT-FAMILY: Tahoma">And obviously, the host only relies on the interface exposed by a plug-in to use its services. This is not specific to this method, but rather an other way of using interfaces with a greater level of abstraction, because concrete types are not known by the host.</SPAN></LI></UL></LI></UL>
<P class=MsoNormal style="MARGIN: 0cm 0cm 0pt; TEXT-ALIGN: justify; mso-margin-top-alt: auto; mso-margin-bottom-alt: auto"><SPAN style="FONT-SIZE: 10pt; FONT-FAMILY: Tahoma">In many ways, true dynamic loading of DLLs using this method is better than the static one. But we’re not in a perfect world and this method also has its drawbacks, some being really vicious.</SPAN></P>
<P class=MsoNormal style="MARGIN: 0cm 0cm 0pt; TEXT-ALIGN: justify; mso-margin-top-alt: auto; mso-margin-bottom-alt: auto"><SPAN style="FONT-SIZE: 10pt; FONT-FAMILY: Tahoma"></SPAN>&nbsp;</P><?xml:namespace prefix = o ns = "urn:schemas-microsoft-com:office:office" /><o:p></o:p></SPAN>
<P class=MsoNormal style="MARGIN: 0cm 0cm 0pt; TEXT-ALIGN: justify; mso-margin-top-alt: auto; mso-margin-bottom-alt: auto"><SPAN style="FONT-SIZE: 10pt; FONT-FAMILY: Tahoma">There are multiple ways for including the <B style="mso-bidi-font-weight: normal">Runtime Library</B>, which is a kind of libc that can be found under Unices. Actually there are three ways:<o:p></o:p></SPAN></P>
<UL type=disc>
<LI class=MsoNormal style="MARGIN: 0cm 0cm 0pt; TEXT-ALIGN: justify; mso-list: l1 level1 lfo2; tab-stops: list 36.0pt; mso-margin-top-alt: auto; mso-margin-bottom-alt: auto"><SPAN style="FONT-SIZE: 10pt; FONT-FAMILY: Tahoma">Including the “SingleThreaded” (ST) version of the library, which is mainly suited for applications that do not use threads,<o:p></o:p></SPAN> 
<LI class=MsoNormal style="MARGIN: 0cm 0cm 0pt; TEXT-ALIGN: justify; mso-list: l1 level1 lfo2; tab-stops: list 36.0pt; mso-margin-top-alt: auto; mso-margin-bottom-alt: auto"><SPAN style="FONT-SIZE: 10pt; FONT-FAMILY: Tahoma">Including the “MultiThreaded” (MT) version that is used when the application is MultiThreaded. RT functions are then optimized to be ThreadSafe, which is not the case for the ST version. This is a static version of the RT that is completely included in the final binary minus, of course, methods you do use.<o:p></o:p></SPAN> 
<LI class=MsoNormal style="MARGIN: 0cm 0cm 0pt; TEXT-ALIGN: justify; mso-list: l1 level1 lfo2; tab-stops: list 36.0pt; mso-margin-top-alt: auto; mso-margin-bottom-alt: auto"><SPAN style="FONT-SIZE: 10pt; FONT-FAMILY: Tahoma">Including the “MultiThreaded DLL” (MD) version – the mostly used version – that references the msvcr7x.dll file. <I style="mso-bidi-font-style: normal">(This changes depending on the C++ compiler. Actually, this used not to change but it created havoc so…) </I>This is, so far, the best way of including the RT as it lightens the weight of binaries and has other implications I will discuss later on.<o:p></o:p></SPAN></LI></UL>
<P class=MsoNormal style="MARGIN: 0cm 0cm 0pt; TEXT-ALIGN: justify; mso-margin-top-alt: auto; mso-margin-bottom-alt: auto"><SPAN style="FONT-SIZE: 10pt; FONT-FAMILY: Tahoma">This parameter can be found in : </SPAN></P>
<P class=MsoNormal style="MARGIN: 0cm 0cm 0pt; TEXT-ALIGN: justify; mso-margin-top-alt: auto; mso-margin-bottom-alt: auto"><SPAN style="FONT-SIZE: 10pt; FONT-FAMILY: Tahoma">&nbsp;</P><o:p></o:p></SPAN>
<P class=MsoNormal style="MARGIN: 0cm 0cm 0pt; TEXT-INDENT: 36pt; TEXT-ALIGN: justify; mso-margin-top-alt: auto; mso-margin-bottom-alt: auto"><B style="mso-bidi-font-weight: normal"><SPAN style="FONT-SIZE: 10pt; FONT-FAMILY: Tahoma">Project Properties / C/C++ / Code Generation / Runtime Library</SPAN></B></P>
<P class=MsoNormal style="MARGIN: 0cm 0cm 0pt; TEXT-INDENT: 36pt; TEXT-ALIGN: justify; mso-margin-top-alt: auto; mso-margin-bottom-alt: auto"><B style="mso-bidi-font-weight: normal"><SPAN style="FONT-SIZE: 10pt; FONT-FAMILY: Tahoma">&nbsp;</P></SPAN></B>
<P class=MsoNormal style="MARGIN: 0cm 0cm 0pt; TEXT-ALIGN: justify; mso-margin-top-alt: auto; mso-margin-bottom-alt: auto"><SPAN style="FONT-SIZE: 10pt; FONT-FAMILY: Tahoma">There is a thing about DLLs and static variables: These are local to their modules <EM>(understand DLL in this context)</EM> and not the current process. In other words, including the RT as a static library in a plug-in/host context creates multiple “instances” of the static variables found in the RT. In particular, it creates independent versions of internal lists used to maintain heap memory allocations. These lists are used, for instance, by malloc or other memory allocation functions.</SPAN></P>
<P class=MsoNormal style="MARGIN: 0cm 0cm 0pt; TEXT-ALIGN: justify; mso-margin-top-alt: auto; mso-margin-bottom-alt: auto"><SPAN style="FONT-SIZE: 10pt; FONT-FAMILY: Tahoma">&nbsp;</P><o:p></o:p></SPAN>
<P class=MsoNormal style="MARGIN: 0cm 0cm 0pt; TEXT-ALIGN: justify; mso-margin-top-alt: auto; mso-margin-bottom-alt: auto"><SPAN style="FONT-SIZE: 10pt; FONT-FAMILY: Tahoma">Knowing this, it becomes obvious that allocating one object from one module (some plug-in) and freeing it in an other module (say the host) leads toward freeing a pointer that does not exist in the destination module. There are many behaviors that can be observed:<o:p></o:p></SPAN></P>
<UL type=disc>
<LI class=MsoNormal style="MARGIN: 0cm 0cm 0pt; TEXT-ALIGN: justify; mso-list: l0 level1 lfo3; tab-stops: list 36.0pt; mso-margin-top-alt: auto; mso-margin-bottom-alt: auto"><SPAN style="FONT-SIZE: 10pt; FONT-FAMILY: Tahoma">The first – which the most common – is the RT assertion dialog box showing up and saying that the pointer being freed is not valid. Most programmers don’t really understand this message and choose to ignore it because they don’t understand it, which is not that good…<o:p></o:p></SPAN> 
<LI class=MsoNormal style="MARGIN: 0cm 0cm 0pt; TEXT-ALIGN: justify; mso-list: l0 level1 lfo3; tab-stops: list 36.0pt; mso-margin-top-alt: auto; mso-margin-bottom-alt: auto"><SPAN style="FONT-SIZE: 10pt; FONT-FAMILY: Tahoma">The second, found if debugging features of the compiler are deactivated, is a simple crash but a really hard bug to spot.<o:p></o:p></SPAN></LI></UL>
<P class=MsoNormal style="MARGIN: 0cm 0cm 0pt; TEXT-ALIGN: justify; mso-margin-top-alt: auto; mso-margin-bottom-alt: auto"><SPAN style="FONT-SIZE: 10pt; FONT-FAMILY: Tahoma">Back in the object oriented world, where everything is encapsulated, you can find that kind of code in the shared interfaces:</SPAN></P>
<P class=MsoNormal style="MARGIN: 0cm 0cm 0pt; TEXT-ALIGN: justify; mso-margin-top-alt: auto; mso-margin-bottom-alt: auto"><SPAN style="FONT-SIZE: 10pt; FONT-FAMILY: Tahoma">&nbsp;</P><o:p></o:p></SPAN>
<P class=MsoNormal style="MARGIN: 0cm 0cm 0pt 36pt; mso-layout-grid-align: none"><SPAN style="FONT-SIZE: 8pt; COLOR: blue; FONT-FAMILY: 'Courier New'">class</SPAN><SPAN style="FONT-SIZE: 8pt; FONT-FAMILY: 'Courier New'"> IObject <o:p></o:p></SPAN></P>
<P class=MsoNormal style="MARGIN: 0cm 0cm 0pt 36pt; mso-layout-grid-align: none"><SPAN style="FONT-SIZE: 8pt; FONT-FAMILY: 'Courier New'">{<o:p></o:p></SPAN></P>
<P class=MsoNormal style="MARGIN: 0cm 0cm 0pt 36pt; mso-layout-grid-align: none"><SPAN style="FONT-SIZE: 8pt; COLOR: blue; FONT-FAMILY: 'Courier New'">public</SPAN><SPAN style="FONT-SIZE: 8pt; FONT-FAMILY: 'Courier New'">:<o:p></o:p></SPAN></P>
<P class=MsoNormal style="MARGIN: 0cm 0cm 0pt 36pt; mso-layout-grid-align: none"><SPAN style="FONT-SIZE: 8pt; FONT-FAMILY: 'Courier New'"><SPAN style="mso-tab-count: 1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN><SPAN style="COLOR: blue">virtual</SPAN> std::vector&lt;<SPAN style="COLOR: blue">int</SPAN>&gt;<SPAN style="mso-tab-count: 1">&nbsp;&nbsp; </SPAN>GetRefs() = <SPAN style="COLOR: fuchsia">0</SPAN>;<BR>};</SPAN></P>
<P class=MsoNormal style="MARGIN: 0cm 0cm 0pt 36pt; mso-layout-grid-align: none"><SPAN style="FONT-SIZE: 8pt; FONT-FAMILY: 'Courier New'"></SPAN><SPAN style="FONT-SIZE: 8pt; FONT-FAMILY: 'Courier New'">&nbsp;</P></SPAN><SPAN style="FONT-SIZE: 10pt; FONT-FAMILY: Tahoma"><o:p></o:p></SPAN>
<P class=MsoNormal style="MARGIN: 0cm 0cm 0pt; TEXT-ALIGN: justify; mso-margin-top-alt: auto; mso-margin-bottom-alt: auto"><SPAN style="FONT-SIZE: 10pt; FONT-FAMILY: Tahoma">Although this is completely correct, the problem with that kind of code is that the vector object itself is generally allocated on the stack (although it depends on the left value used in the assignation) but contained data is allocated on the heap. This is a hidden memory allocation that can cause trouble when using the Static MultiThreaded version of the RT, leading – when you are lucky – to a crash and when you’re not, the kind of behavior my students have been experiencing, like a partial destruction of the heap and/or the stack…</SPAN></P>
<P class=MsoNormal style="MARGIN: 0cm 0cm 0pt; TEXT-ALIGN: justify; mso-margin-top-alt: auto; mso-margin-bottom-alt: auto"><SPAN style="FONT-SIZE: 10pt; FONT-FAMILY: Tahoma">&nbsp;</P><o:p></o:p></SPAN>
<P class=MsoNormal style="MARGIN: 0cm 0cm 0pt; TEXT-ALIGN: justify; mso-margin-top-alt: auto; mso-margin-bottom-alt: auto"><SPAN style="FONT-SIZE: 10pt; FONT-FAMILY: Tahoma">In other words: Use the “MultiThreaded DLL” version of the Runtime Library <B style="mso-bidi-font-weight: normal">in all the binaries and static libraries of your projects. </B><SPAN style="mso-spacerun: yes">&nbsp;</SPAN>Note that I insist heavily on the fact that the <B style="mso-bidi-font-weight: normal">same</B> runtime must be used everywhere, otherwise you’ll get <B style="mso-bidi-font-weight: normal">a lot</B> of strange linker warnings and errors. <I style="mso-bidi-font-style: normal">(This is mainly because the same symbols are not exposed in the same way, static and dll imported)</I></SPAN></P>
<P class=MsoNormal style="MARGIN: 0cm 0cm 0pt; TEXT-ALIGN: justify; mso-margin-top-alt: auto; mso-margin-bottom-alt: auto"><SPAN style="FONT-SIZE: 10pt; FONT-FAMILY: Tahoma"><I style="mso-bidi-font-style: normal">&nbsp;</P></I><o:p></o:p></SPAN>
<P class=MsoNormal style="MARGIN: 0cm 0cm 0pt; TEXT-ALIGN: justify; mso-margin-top-alt: auto; mso-margin-bottom-alt: auto"><SPAN style="FONT-SIZE: 10pt; FONT-FAMILY: Tahoma">By the way, in the .NET world it is mandatory when using Managed C++ extensions, probably for the same reason…<o:p></o:p></SPAN></P>
{% include imported_disclaimer.html %}
