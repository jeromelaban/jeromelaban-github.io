---
layout: post
title: "The Disposable Pattern, Determinism in the .NET World"
date: 2004-08-16 11:43:00 -0500
comments: true
category: Archive
tags: [".NET"]
redirect_from: ["/post/2004/08/16/The-Disposable-Pattern2c-Determinism-in-the-NET-World.aspx", "/post/2004/08/16/the-disposable-pattern2c-determinism-in-the-net-world.aspx"]
author: jerome
---
<!-- more -->
<span style="font-family: Tahoma"><font size="2">One of the numerous features that can be found in the CLR is the garbage collection. Depending on the programmer&rsquo;s background, this can be a little disturbing, having the habit to manage the memory by hand (especially for plain C programmers).</font></span><span style="font-family: Tahoma"><font size="2">&nbsp;</font></span><span style="font-family: Tahoma"><font size="2">For C++ developers for instance, even though the memory management can be abstracted by the use of the STL, the C++ has a pretty strong model that provides a deterministic way of handling memory allocations. Once an object has reach the end of its life, either by the control flow leaving the scope or the container object being destroyed, the object is immediately destroyed. This is done by the C++ compiler that calls the object&rsquo;s destructors and releases the memory.</font></span><span style="font-family: Tahoma"><font size="2">&nbsp;</font></span><span style="font-family: Tahoma"><font size="2">The CLR model is, however, weaker than that. The Garbage Collector (GC) is generally more efficient than the programmer and it handles objects destruction in an asynchronous way. When an object is created, it has the ability to provide the GC a special method named the Finalizer, which is called by the GC when it needs to reclaim the memory used by the object. This can be done at any time by an internal CLR thread, only when necessary.</font></span><span style="font-family: Tahoma"><font size="2">&nbsp;</font></span><span style="font-family: Tahoma"><font size="2">This means that the memory management is really efficient and fast. This also means that it can fit the environment the program is running in by efficiently using the available memory. The effect of this asynchronous behavior is that there is no way to have a deterministic destruction of objects. This is one of the most frequent critics of programmers beginning with .NET programming.</font></span><span style="font-family: Tahoma"><font size="2">&nbsp;</font></span><span style="font-family: Tahoma"><font size="2">The biggest trap in this area for C++ developers is the syntax of the finalizer in managed C++ and C#. For instance, in C# :</font></span><span style="font-family: Tahoma">&nbsp;</span><span style="font-size: 10pt; font-family: 'Lucida Console'"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span style="color: blue">class</span> <span style="color: teal">Program</span></span><span style="font-size: 10pt; font-family: 'Lucida Console'"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>{</span><span style="font-size: 10pt; font-family: 'Lucida Console'"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span style="color: blue">static</span> <span style="color: blue">void</span> Main(<span style="color: blue">string</span>[] args)</span><span style="font-size: 10pt; font-family: 'Lucida Console'"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>{</span><span style="font-size: 10pt; font-family: 'Lucida Console'"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>{</span><span style="font-size: 10pt; font-family: 'Lucida Console'"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span style="color: teal">Dummy</span> dummy = <span style="color: blue">new</span> <span style="color: teal">Dummy</span>();</span><span style="font-size: 10pt; font-family: 'Lucida Console'"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>}</span><span style="font-size: 10pt; font-family: 'Lucida Console'">&nbsp;</span><span style="font-size: 10pt; font-family: 'Lucida Console'"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span style="color: teal">Console</span>.WriteLine(<span style="color: fuchsia">&quot;End of main.&quot;</span>);</span><span style="font-size: 10pt; font-family: 'Lucida Console'"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>}</span><span style="font-size: 10pt; font-family: 'Lucida Console'"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>}</span><span style="font-size: 10pt; font-family: 'Lucida Console'">&nbsp;</span><span style="font-size: 10pt; font-family: 'Lucida Console'"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span style="color: blue">public</span> <span style="color: blue">class</span> <span style="color: teal">Dummy</span></span><span style="font-size: 10pt; font-family: 'Lucida Console'"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>{</span><span style="font-size: 10pt; font-family: 'Lucida Console'"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>~<span style="color: teal">Dummy</span>()</span><span style="font-size: 10pt; font-family: 'Lucida Console'"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>{</span><span style="font-size: 10pt; font-family: 'Lucida Console'"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span style="color: teal">Console</span>.WriteLine(<span style="color: fuchsia">&quot;Dummy.~Dummy()&quot;</span>);</span><span style="font-size: 10pt; font-family: 'Lucida Console'"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>}</span><span style="font-size: 10pt; font-family: 'Lucida Console'"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>}</span><span style="font-size: 10pt; font-family: 'Lucida Console'">&nbsp;</span><span style="font-family: Tahoma"><font size="2">Since the instanciation of the Dummy class is between brackets, a C++ programmer would think that the so called destructor is called right at end of the scope, before the last WriteLine. In reality, the GC will call the Finalizer when the memory is reclaimed : At the end of the program execution. A concrete view of this problem is often found when using file IO :</font></span><span style="font-family: Tahoma"></span><span style="font-family: Tahoma">&nbsp;</span><span style="font-size: 10pt; font-family: 'Lucida Console'"><span>&nbsp; </span><span style="color: blue">class</span> <span style="color: teal">Program</span></span><span style="font-size: 10pt; font-family: 'Lucida Console'"><span>&nbsp; </span>{</span><span style="font-size: 10pt; font-family: 'Lucida Console'"><span>&nbsp; </span><span>&nbsp;&nbsp;</span><span style="color: blue">static</span> <span style="color: blue">void</span> Main(<span style="color: blue">string</span>[] args)</span><span style="font-size: 10pt; font-family: 'Lucida Console'"><span>&nbsp; </span><span>&nbsp;&nbsp;</span>{</span><span style="font-size: 10pt; font-family: 'Lucida Console'"><span>&nbsp; </span><span>&nbsp;&nbsp;</span><span>&nbsp;&nbsp;</span><span style="color: teal">StreamWriter</span> writer = <span style="color: teal">File</span>.OpenWrite(<span style="color: fuchsia">&quot;Test.txt&quot;</span>);</span><span style="font-size: 10pt; font-family: 'Lucida Console'"><span>&nbsp; </span><span>&nbsp;&nbsp;</span><span>&nbsp;&nbsp;</span>writer.Write(<span style="color: fuchsia">&quot;Some value&quot;</span>);</span><span style="font-size: 10pt; font-family: 'Lucida Console'">&nbsp;</span><span style="font-size: 10pt; font-family: 'Lucida Console'"><span>&nbsp; </span><span>&nbsp;&nbsp;</span><span>&nbsp;&nbsp;</span><span style="color: teal">Console</span>.ReadLine();</span><span style="font-size: 10pt; font-family: 'Lucida Console'"><span>&nbsp; </span><span>&nbsp;&nbsp;</span>}</span><span style="font-size: 10pt; font-family: 'Lucida Console'"><span>&nbsp; </span>}</span><span style="font-size: 11pt; font-family: Tahoma">&nbsp;</span><span style="font-family: Tahoma"><font size="2">The problem with this program is that the writer is not closed. It will <strong>eventually</strong> be closed when the GC will call the finalizer of the writer intance, thus closing the file. This is a common problem found in C# programs, leaving some file handles opened, preventing the files to be opened by some other program.</font></span><span style="font-family: Tahoma"><font size="2">&nbsp;</font></span><span style="font-family: Tahoma"><font size="2">To fix this problem, there are two methods :</font></span> 
<ul style="margin-top: 0cm">
	<li class="MsoNormal" style="margin: 0cm 0cm 0pt; text-align: justify; tab-stops: list 36.0pt"><span style="font-family: Tahoma"><font size="2">Call the StreamWriter.Close method when the stream is not used anymore, </font></span></li>
	<li class="MsoNormal" style="margin: 0cm 0cm 0pt; text-align: justify; tab-stops: list 36.0pt"><span style="font-family: Tahoma"><font size="2">Use the <strong>using</strong> keyword to limit the scope of the object.</font></span></li>
</ul>
<span style="font-family: Tahoma"><font size="2">&nbsp;</font></span><span style="font-family: Tahoma"><font size="2">The using keyword is a shortcut in the C# language to call a method of the System.IDisposable interface, at the and of its scope. In pratice this is what that means :</font></span><span style="font-family: Tahoma">&nbsp;</span><span style="font-size: 10pt; font-family: 'Lucida Console'"><span>&nbsp; </span><span style="color: blue">static</span> <span style="color: blue">void</span> Main(<span style="color: blue">string</span>[] args)</span><span style="font-size: 10pt; font-family: 'Lucida Console'"><span>&nbsp; </span>{</span><span style="font-size: 10pt; font-family: 'Lucida Console'"><span>&nbsp; </span><span>&nbsp;&nbsp;</span><span style="color: blue">using</span> (<span style="color: teal">StreamWriter</span> writer = <span style="color: blue">new</span> <span style="color: teal">StreamWriter</span>(<span style="color: teal">File</span>.OpenWrite(<span style="color: fuchsia">&quot;Test.txt&quot;</span>)))</span><span style="font-size: 10pt; font-family: 'Lucida Console'"><span>&nbsp; </span><span>&nbsp;&nbsp;</span>{</span><span style="font-size: 10pt; font-family: 'Lucida Console'"><span>&nbsp; </span><span>&nbsp;&nbsp;</span><span>&nbsp;&nbsp;</span>writer.Write(<span style="color: fuchsia">&quot;Some value&quot;</span>);</span><span style="font-size: 10pt; font-family: 'Lucida Console'"><span>&nbsp; </span><span>&nbsp;&nbsp;</span>}</span><span style="font-size: 10pt; font-family: 'Lucida Console'"><span>&nbsp; </span>}</span><span style="font-family: Tahoma">&nbsp;</span><span style="font-family: Tahoma"><font size="2">Which is in fact expanded by the C# compiler to :</font></span><span style="font-family: Tahoma">&nbsp;</span><span style="font-size: 10pt; font-family: 'Lucida Console'"><span>&nbsp; </span><span style="color: blue">static</span> <span style="color: blue">void</span> Main(<span style="color: blue">string</span>[] args)</span><span style="font-size: 10pt; font-family: 'Lucida Console'"><span>&nbsp; </span>{</span><span style="font-size: 10pt; font-family: 'Lucida Console'"><span>&nbsp; </span><span>&nbsp;&nbsp;</span><span style="color: teal">StreamWriter</span> writer = <span style="color: blue">new</span> <span style="color: teal">StreamWriter</span>(<span style="color: teal">File</span>.OpenWrite(<span style="color: fuchsia">&quot;Test.txt&quot;</span>));</span><span style="font-size: 10pt; font-family: 'Lucida Console'">&nbsp;</span><span style="font-size: 10pt; font-family: 'Lucida Console'"><span>&nbsp;</span><span>&nbsp;</span><span>&nbsp; </span><span style="color: blue">try</span> {</span><span style="font-size: 10pt; font-family: 'Lucida Console'"><span>&nbsp;</span><span>&nbsp;</span><span>&nbsp; </span><span>&nbsp;&nbsp;</span>writer.Write(<span style="color: fuchsia">&quot;Some value&quot;</span>);</span><span style="font-size: 10pt; font-family: 'Lucida Console'"><span>&nbsp;</span><span>&nbsp;</span><span>&nbsp; </span>}</span><span style="font-size: 10pt; font-family: 'Lucida Console'"><span>&nbsp; </span><span>&nbsp;</span><span>&nbsp;</span><span style="color: blue">finally</span> {</span><span style="font-size: 10pt; font-family: 'Lucida Console'"><span>&nbsp; </span><span>&nbsp;&nbsp;</span><span>&nbsp;&nbsp;</span>writer.Dispose();</span><span style="font-size: 10pt; font-family: 'Lucida Console'"><span>&nbsp; </span><span>&nbsp;&nbsp;</span>}</span><span style="font-size: 10pt; font-family: 'Lucida Console'"><span>&nbsp; </span>}</span><span style="font-family: 'Lucida Console'"></span><span style="font-family: Tahoma">&nbsp;</span><span style="font-family: Tahoma"><font size="2">This is straightforward, the Dispose method is called at the end of the &ldquo;using&rdquo; scope. One thing though, this does not mean that the memory allocated for the StreamWriter instance is reclaimed right after the dispose. This only means that the instance will release the &ldquo;unmanaged&rdquo; objects it holds. A file handle in this case.</font></span><span style="font-family: Tahoma"><font size="2">&nbsp;</font></span><span style="font-family: Tahoma"><font size="2">But one might say : &ldquo;But if the programmer forgets to call Dispose or Close, the file is not closed at the end&rdquo;. Actually, no. This is where the Disposable pattern enters the scene.</font></span><span style="font-family: Tahoma"><font size="2">&nbsp;</font></span><span style="font-family: Tahoma"><font size="2">The good thing about this is that you can combine the Dispose method and the GC, the GC being the safekeeper of the unamanged resources of the object; Even if the programmer forgets to call the Close or Dispose method.</font></span><span style="font-family: Tahoma"><font size="2">&nbsp;</font></span><span style="font-family: Tahoma"><font size="2">Here is an example of a Disposable type that implements the Disposable pattern:</font></span><span style="font-family: Tahoma">&nbsp;</span><span style="font-size: 10pt; font-family: 'Lucida Console'"><span>&nbsp; </span><span style="color: blue">public</span> <span style="color: blue">class</span> <span style="color: teal">MyDisposable</span> : <span style="color: teal">IDisposable</span></span><span style="font-size: 10pt; font-family: 'Lucida Console'"><span>&nbsp; </span>{</span><span style="font-size: 10pt; font-family: 'Lucida Console'"><span>&nbsp; </span><span>&nbsp;&nbsp;</span><span style="color: blue">public</span> <span style="color: blue">void</span> Dispose()</span><span style="font-size: 10pt; font-family: 'Lucida Console'"><span>&nbsp; </span><span>&nbsp;&nbsp;</span>{</span><span style="font-size: 10pt; font-family: 'Lucida Console'"><span>&nbsp; </span><span>&nbsp;&nbsp;</span><span>&nbsp;&nbsp;</span>Dispose(<span style="color: blue">true</span>);</span><span style="font-size: 10pt; font-family: 'Lucida Console'"><span>&nbsp; </span><span>&nbsp;&nbsp;</span>}</span><span style="font-size: 10pt; font-family: 'Lucida Console'">&nbsp;</span><span style="font-size: 10pt; font-family: 'Lucida Console'"><span>&nbsp; </span><span>&nbsp;&nbsp;</span>~<span style="color: teal">MyDisposable</span>()</span><span style="font-size: 10pt; font-family: 'Lucida Console'"><span>&nbsp; </span><span>&nbsp;&nbsp;</span>{</span><span style="font-size: 10pt; font-family: 'Lucida Console'"><span>&nbsp; </span><span>&nbsp;&nbsp;</span><span>&nbsp;&nbsp;</span>Dispose(<span style="color: blue">false</span>);</span><span style="font-size: 10pt; font-family: 'Lucida Console'"><span>&nbsp; </span><span>&nbsp;&nbsp;</span>}</span><span style="font-size: 10pt; font-family: 'Lucida Console'">&nbsp;</span><span style="font-size: 10pt; font-family: 'Lucida Console'"><span>&nbsp; </span><span>&nbsp;&nbsp;</span><span style="color: blue">private</span> <span style="color: blue">void</span> Dispose(<span style="color: blue">bool</span> disposing)</span><span style="font-size: 10pt; font-family: 'Lucida Console'"><span>&nbsp; </span><span>&nbsp;&nbsp;</span>{</span><span style="font-size: 10pt; font-family: 'Lucida Console'"><span>&nbsp; </span><span>&nbsp;&nbsp;</span><span>&nbsp;&nbsp;</span><span style="color: green">// If we come from the Dispose method, suppress the</span></span><span style="font-size: 10pt; font-family: 'Lucida Console'"><span>&nbsp; </span><span>&nbsp;&nbsp;</span><span>&nbsp;&nbsp;</span><span style="color: green">// finalize method, so this instance is only disposed</span></span><span style="font-size: 10pt; font-family: 'Lucida Console'"><span>&nbsp; </span><span>&nbsp;&nbsp;</span><span>&nbsp;&nbsp;</span><span style="color: green">// once.</span></span><span style="font-size: 10pt; font-family: 'Lucida Console'"><span>&nbsp; </span><span>&nbsp;&nbsp;</span><span>&nbsp;&nbsp;</span><span style="color: blue">if</span> (disposing)</span><span style="font-size: 10pt; font-family: 'Lucida Console'"><span>&nbsp; </span><span>&nbsp;&nbsp;</span><span>&nbsp;&nbsp;</span><span>&nbsp;&nbsp;</span><span style="color: teal">GC</span>.SuppressFinalize(<span style="color: blue">this</span>);</span><span style="font-size: 10pt; font-family: 'Lucida Console'">&nbsp;</span><span style="font-size: 10pt; font-family: 'Lucida Console'"><span>&nbsp; </span><span>&nbsp;&nbsp;</span><span>&nbsp;&nbsp;</span><span style="color: green">// Release any unmanaged resource</span></span><span style="font-size: 10pt; font-family: 'Lucida Console'"><span>&nbsp; </span><span>&nbsp;&nbsp;</span><span>&nbsp;&nbsp;</span><span style="color: green">// ...</span></span><span style="font-size: 10pt; font-family: 'Lucida Console'"><span>&nbsp; </span><span>&nbsp;&nbsp;</span>}</span><span style="font-size: 10pt; font-family: 'Lucida Console'"><span>&nbsp; </span>}</span><span style="font-size: 10pt; font-family: 'Lucida Console'">&nbsp;</span><span style="font-family: Tahoma"><font size="2">This class implements implicitly the IDisposable interface, by defining the Dispose method. Here, both the Dispose method and the Finalizer call an overload of the Dispose method. This method is the code that will actually release unmanaged resources.</font></span><span style="font-family: Tahoma"><font size="2">&nbsp;</font></span><span style="font-family: Tahoma"><font size="2">You might note the use of the GC.SuppressFinalize method, that prevents the GC from calling the Dispose method again from the Finalize method. This also has a alternate objective: Remove some pressure on the GC, as finalizing objects is rather expensive.</font></span><span style="font-family: Tahoma"><font size="2">This pattern can also be completed by an &ldquo;already disposed&rdquo; check, to avoid multiple Dispose calls. There are two possible behaviors there : Either silently ignore any subsquent calls, or throw a DisposedException. Using one or the other is a matter of context.</font></span><span style="font-family: Tahoma"><font size="2">&nbsp;</font></span> 
<p style="margin: 0cm 0cm 0pt; text-align: justify" class="MsoNormal">
<span style="font-family: Tahoma"><font size="2">While not every object needs to be finalizable (and disposable), each time you add a finalizer, you should also implement the System.IDisposable interface and the Disposable pattern.</font></span>
</p>
?&gt; 

{% include imported_disclaimer.html %}
